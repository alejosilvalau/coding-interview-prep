class Solution:
  def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
      result = []

      def depth_first_search(index: int, current_combination: List[int], current_sum: int):
          # If we hit the target, add a copy of the current combination
          if current_sum == target:
              result.append(current_combination.copy())
              return

          # If out of bounds or sum exceeded, stop exploring this path
          if index >= len(candidates) or current_sum > target:
              return

          # Include the current number and stay at the same index (can reuse)
          current_combination.append(candidates[index])
          depth_first_search(index, current_combination, current_sum + candidates[index])
          current_combination.pop()

          # Skip the current number and move to the next index
          depth_first_search(index + 1, current_combination, current_sum)

      depth_first_search(0, [], 0)
      return result
